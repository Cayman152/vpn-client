name: Ghost VPN macOS Build

on:
  push:
    branches:
      - master
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Optional release tag (example: v0.1.0)"
        required: false
        type: string

permissions:
  contents: write

env:
  OutputPathArm64: "${{ github.workspace }}/build/ghost-vpn-macos-arm64"
  OutputPathX64: "${{ github.workspace }}/build/ghost-vpn-macos-x64"
  ArtifactDir: "${{ github.workspace }}/artifacts"
  SetupPathArm64: "${{ github.workspace }}/artifacts/GhostVPN-macOS-arm64.dmg"
  SetupPathX64: "${{ github.workspace }}/artifacts/GhostVPN-macOS-x64.dmg"
  RollingReleaseTag: "ghost-vpn-latest"

jobs:
  build:
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: "recursive"
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Resolve source paths
        shell: pwsh
        run: |
          $sourceRoot = (Resolve-Path "./GhostVPN").Path
          $desktopProject = Join-Path $sourceRoot "GhostVPN.Desktop/GhostVPN.Desktop.csproj"
          $propsPath = Join-Path $sourceRoot "Directory.Build.props"

          foreach ($requiredPath in @($desktopProject, $propsPath)) {
            if (-not (Test-Path $requiredPath)) {
              throw "Required path not found: $requiredPath"
            }
          }

          "SOURCE_ROOT=$sourceRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "PROJECT_DESKTOP=$desktopProject" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "PROPS_PATH=$propsPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Resolve app version
        shell: pwsh
        run: |
          $tag = "${{ github.event.inputs.release_tag }}".Trim()
          if ($tag) {
            if ($tag.StartsWith("v")) {
              $tag = $tag.Substring(1)
            }
            $version = $tag
          }
          else {
            [xml]$props = Get-Content $env:PROPS_PATH
            $baseVersion = $props.Project.PropertyGroup[0].Version
            $version = "$baseVersion.${{ github.run_number }}"
          }
          "APP_VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Build desktop osx-arm64 and osx-x64
        shell: pwsh
        run: |
          dotnet publish "$env:PROJECT_DESKTOP" -c Release -r osx-arm64 -p:SelfContained=true -p:PublishSingleFile=false -p:TreatWarningsAsErrors=false -p:WarningsAsErrors= -p:NoWarn=CS8625 -o "$env:OutputPathArm64"
          dotnet publish "$env:PROJECT_DESKTOP" -c Release -r osx-x64 -p:SelfContained=true -p:PublishSingleFile=false -p:TreatWarningsAsErrors=false -p:WarningsAsErrors= -p:NoWarn=CS8625 -o "$env:OutputPathX64"

          foreach ($outPath in @($env:OutputPathArm64, $env:OutputPathX64)) {
            $desktopBin = Join-Path $outPath "GhostVPN"
            if (-not (Test-Path $desktopBin)) {
              throw "GhostVPN executable was not produced by desktop publish: $desktopBin"
            }
          }

      - name: Download core binaries (xray/sing-box)
        shell: pwsh
        run: |
          $headers = @{
            "User-Agent" = "ghost-vpn-build"
            "Accept" = "application/vnd.github+json"
          }

          $tmpRoot = Join-Path $env:RUNNER_TEMP "ghostvpn-cores-macos"
          New-Item -ItemType Directory -Path $tmpRoot -Force | Out-Null

          function Get-LatestAsset {
            param(
              [string]$Repo,
              [string[]]$Patterns
            )

            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$Repo/releases/latest" -Headers $headers
            if (-not $release -or -not $release.assets) {
              throw "Release metadata has no assets for repository '$Repo'"
            }

            $asset = $null
            $matchedPattern = $null
            foreach ($pattern in $Patterns) {
              $asset = $release.assets | Where-Object { $_.name -match $pattern } | Select-Object -First 1
              if ($asset) {
                $matchedPattern = $pattern
                break
              }
            }

            if (-not $asset) {
              $availableAssets = ($release.assets | Select-Object -ExpandProperty name | Select-Object -First 120) -join ", "
              $patternsText = ($Patterns -join "; ")
              throw "No asset matched any pattern '$patternsText' for repository '$Repo'. Available assets sample: $availableAssets"
            }

            Write-Host "Selected asset for ${Repo}: $($asset.name) (pattern: $matchedPattern)"

            return [PSCustomObject]@{
              Tag = $release.tag_name
              Name = $asset.name
              Url = $asset.browser_download_url
            }
          }

          function Expand-CoreArchive {
            param(
              [string]$ArchivePath,
              [string]$ExtractPath
            )

            New-Item -ItemType Directory -Path $ExtractPath -Force | Out-Null
            if ($ArchivePath.EndsWith(".zip")) {
              Expand-Archive -Path $ArchivePath -DestinationPath $ExtractPath -Force
            }
            elseif ($ArchivePath.EndsWith(".tar.gz") -or $ArchivePath.EndsWith(".tgz")) {
              tar -xzf $ArchivePath -C $ExtractPath
            }
            elseif ($ArchivePath.EndsWith(".tar.xz")) {
              tar -xJf $ArchivePath -C $ExtractPath
            }
            else {
              throw "Unsupported archive format: $ArchivePath"
            }
          }

          function Install-CoreFromArchive {
            param(
              [string]$DownloadUrl,
              [string]$ArchiveName,
              [string]$ExecutableName,
              [string]$TargetDir
            )

            $archivePath = Join-Path $tmpRoot $ArchiveName
            $extractPath = Join-Path $tmpRoot ([System.IO.Path]::GetFileNameWithoutExtension([System.IO.Path]::GetFileNameWithoutExtension($ArchiveName)))

            Invoke-WebRequest -Uri $DownloadUrl -OutFile $archivePath
            Expand-CoreArchive -ArchivePath $archivePath -ExtractPath $extractPath

            $exePath = Get-ChildItem -Path $extractPath -File -Recurse |
              Where-Object { $_.Name -ieq $ExecutableName } |
              Select-Object -First 1

            if (-not $exePath) {
              throw "Executable '$ExecutableName' not found in package '$ArchiveName'"
            }

            New-Item -ItemType Directory -Path $TargetDir -Force | Out-Null
            Copy-Item -Path (Join-Path $exePath.Directory.FullName "*") -Destination $TargetDir -Recurse -Force
          }

          function Prepare-CoreForArch {
            param(
              [string]$OutPath,
              [string]$ArchLabel,
              [string[]]$XrayPatterns,
              [string[]]$SingBoxPatterns
            )

            $xrayAsset = Get-LatestAsset -Repo "XTLS/Xray-core" -Patterns $XrayPatterns
            $singBoxAsset = Get-LatestAsset -Repo "SagerNet/sing-box" -Patterns $SingBoxPatterns

            $xrayTarget = Join-Path $OutPath "bin/xray"
            $singBoxTarget = Join-Path $OutPath "bin/sing_box"
            $binRoot = Join-Path $OutPath "bin"

            Install-CoreFromArchive -DownloadUrl $xrayAsset.Url -ArchiveName $xrayAsset.Name -ExecutableName "xray" -TargetDir $xrayTarget
            Install-CoreFromArchive -DownloadUrl $singBoxAsset.Url -ArchiveName $singBoxAsset.Name -ExecutableName "sing-box" -TargetDir $singBoxTarget

            foreach ($geoFile in @("geoip.dat", "geosite.dat")) {
              $sourceGeo = Join-Path $xrayTarget $geoFile
              if (Test-Path $sourceGeo) {
                New-Item -ItemType Directory -Path $binRoot -Force | Out-Null
                Copy-Item -Path $sourceGeo -Destination (Join-Path $binRoot $geoFile) -Force
              }
            }

            foreach ($candidate in @(
              (Join-Path $xrayTarget "xray"),
              (Join-Path $singBoxTarget "sing-box"),
              (Join-Path $singBoxTarget "sing-box-client")
            )) {
              if (Test-Path $candidate) {
                chmod +x $candidate
              }
            }
          }

          Prepare-CoreForArch `
            -OutPath $env:OutputPathArm64 `
            -ArchLabel "osx-arm64" `
            -XrayPatterns @(
              "^Xray-(macos|darwin)-arm64.*\.zip$",
              "^Xray-(macos|darwin)-aarch64.*\.zip$",
              "^Xray-(macos|darwin)-.*arm64.*\.zip$",
              "^Xray-(macos|darwin)-.*aarch64.*\.zip$"
            ) `
            -SingBoxPatterns @(
              "^sing-box-.*-(darwin|macos)-arm64\.(tar\.gz|zip)$",
              "^sing-box-.*-(darwin|macos)-aarch64\.(tar\.gz|zip)$",
              "^sing-box-.*(darwin|macos).*(arm64|aarch64).*\.(tar\.gz|zip)$"
            )

          Prepare-CoreForArch `
            -OutPath $env:OutputPathX64 `
            -ArchLabel "osx-x64" `
            -XrayPatterns @(
              "^Xray-(macos|darwin)-64\.zip$",
              "^Xray-(macos|darwin)-x64.*\.zip$",
              "^Xray-(macos|darwin)-amd64.*\.zip$",
              "^Xray-(macos|darwin)-x86_64.*\.zip$",
              "^Xray-(macos|darwin)-.*(64|x64|amd64|x86_64).*\.zip$"
            ) `
            -SingBoxPatterns @(
              "^sing-box-.*-(darwin|macos)-(amd64|x64|x86_64)\.(tar\.gz|zip)$",
              "^sing-box-.*(darwin|macos).*(amd64|x64|x86_64).*\.(tar\.gz|zip)$"
            )

      - name: Verify bundled core binaries
        shell: pwsh
        run: |
          function Assert-CoreFiles {
            param([string]$OutPath, [string]$ArchLabel)

            $desktopBin = Join-Path $OutPath "GhostVPN"
            if (-not (Test-Path $desktopBin)) {
              throw "Missing required desktop executable for ${ArchLabel}: $desktopBin"
            }

            $xray = Join-Path $OutPath "bin/xray/xray"
            if (-not (Test-Path $xray)) {
              throw "Missing required core file for ${ArchLabel}: $xray"
            }

            $geoIpCandidates = @(
              (Join-Path $OutPath "bin/geoip.dat"),
              (Join-Path $OutPath "bin/xray/geoip.dat")
            )
            $hasGeoIp = $geoIpCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
            if (-not $hasGeoIp) {
              $joined = ($geoIpCandidates -join ", ")
              throw "Missing required geoip.dat for ${ArchLabel}. Checked: $joined"
            }

            $geoSiteCandidates = @(
              (Join-Path $OutPath "bin/geosite.dat"),
              (Join-Path $OutPath "bin/xray/geosite.dat")
            )
            $hasGeoSite = $geoSiteCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
            if (-not $hasGeoSite) {
              $joined = ($geoSiteCandidates -join ", ")
              throw "Missing required geosite.dat for ${ArchLabel}. Checked: $joined"
            }

            $singBoxCandidates = @(
              (Join-Path $OutPath "bin/sing_box/sing-box"),
              (Join-Path $OutPath "bin/sing_box/sing-box-client")
            )
            $hasSingBox = $singBoxCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
            if (-not $hasSingBox) {
              $joined = ($singBoxCandidates -join ", ")
              throw "Missing required sing-box executable for ${ArchLabel}. Checked: $joined"
            }
          }

          Assert-CoreFiles -OutPath $env:OutputPathArm64 -ArchLabel "osx-arm64"
          Assert-CoreFiles -OutPath $env:OutputPathX64 -ArchLabel "osx-x64"

      - name: Package macOS DMG installers
        shell: pwsh
        run: |
          function New-MacDmg {
            param(
              [string]$OutPath,
              [string]$ArchLabel,
              [string]$DmgPath
            )

            $bundleRoot = Join-Path $env:RUNNER_TEMP "GhostVPN-$ArchLabel-bundle"
            if (Test-Path $bundleRoot) {
              Remove-Item -Path $bundleRoot -Recurse -Force
            }

            $appRoot = Join-Path $bundleRoot "GhostVPN.app"
            $macOsDir = Join-Path $appRoot "Contents/MacOS"
            $resourcesDir = Join-Path $appRoot "Contents/Resources"
            New-Item -ItemType Directory -Path $macOsDir -Force | Out-Null
            New-Item -ItemType Directory -Path $resourcesDir -Force | Out-Null

            Copy-Item -Path (Join-Path $OutPath "*") -Destination $macOsDir -Recurse -Force

            $icnsSource = Join-Path $macOsDir "GhostVPN.icns"
            if (Test-Path $icnsSource) {
              Copy-Item -Path $icnsSource -Destination (Join-Path $resourcesDir "AppIcon.icns") -Force
            }

            "When this file exists, app will not store configs under this folder" | Set-Content -Path (Join-Path $macOsDir "NotStoreConfigHere.txt") -Encoding utf8

            $plistPath = Join-Path $appRoot "Contents/Info.plist"
            $plistLines = @(
              '<?xml version="1.0" encoding="UTF-8"?>',
              '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">',
              '<plist version="1.0">',
              '<dict>',
              '  <key>CFBundleDevelopmentRegion</key>',
              '  <string>English</string>',
              '  <key>CFBundleDisplayName</key>',
              '  <string>GhostVPN</string>',
              '  <key>CFBundleExecutable</key>',
              '  <string>GhostVPN</string>',
              '  <key>CFBundleIconFile</key>',
              '  <string>AppIcon</string>',
              '  <key>CFBundleIconName</key>',
              '  <string>AppIcon</string>',
              '  <key>CFBundleIdentifier</key>',
              '  <string>com.ghostvpn.client</string>',
              '  <key>CFBundleName</key>',
              '  <string>GhostVPN</string>',
              '  <key>CFBundlePackageType</key>',
              '  <string>APPL</string>',
              '  <key>CFBundleShortVersionString</key>',
              "  <string>$($env:APP_VERSION)</string>",
              '  <key>CFBundleVersion</key>',
              "  <string>$($env:APP_VERSION)</string>",
              '  <key>CSResourcesFileMapped</key>',
              '  <true/>',
              '  <key>NSHighResolutionCapable</key>',
              '  <true/>',
              '  <key>LSMinimumSystemVersion</key>',
              '  <string>12.7</string>',
              '</dict>',
              '</plist>'
            )
            $plistLines | Set-Content -Path $plistPath -Encoding utf8

            foreach ($candidate in @(
              (Join-Path $macOsDir "GhostVPN"),
              (Join-Path $macOsDir "bin/xray/xray"),
              (Join-Path $macOsDir "bin/sing_box/sing-box"),
              (Join-Path $macOsDir "bin/sing_box/sing-box-client")
            )) {
              if (Test-Path $candidate) {
                chmod +x $candidate
              }
            }

            # Ad-hoc sign the bundle to avoid Gatekeeper "app is damaged" errors on unsigned artifacts.
            & /usr/bin/codesign --force --deep --sign - --timestamp=none $appRoot
            & /usr/bin/codesign --verify --deep --strict --verbose=2 $appRoot

            $dmgRoot = Join-Path $env:RUNNER_TEMP "GhostVPN-$ArchLabel-dmg-root"
            if (Test-Path $dmgRoot) {
              Remove-Item -Path $dmgRoot -Recurse -Force
            }
            New-Item -ItemType Directory -Path $dmgRoot -Force | Out-Null
            Copy-Item -Path $appRoot -Destination $dmgRoot -Recurse -Force

            New-Item -ItemType Directory -Path $env:ArtifactDir -Force | Out-Null
            if (Test-Path $DmgPath) {
              Remove-Item -Path $DmgPath -Force
            }

            & /usr/bin/hdiutil create -volname "Ghost VPN Installer" -srcfolder $dmgRoot -ov -format UDZO $DmgPath
            if (-not (Test-Path $DmgPath)) {
              throw "DMG was not created: $DmgPath"
            }
          }

          New-MacDmg -OutPath $env:OutputPathArm64 -ArchLabel "arm64" -DmgPath $env:SetupPathArm64
          New-MacDmg -OutPath $env:OutputPathX64 -ArchLabel "x64" -DmgPath $env:SetupPathX64

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ghost-vpn-macos
          path: |
            ${{ env.SetupPathArm64 }}
            ${{ env.SetupPathX64 }}
          retention-days: 14

      - name: Publish build summary
        shell: pwsh
        run: |
          @"
          ## Ghost VPN macOS build artifacts
          - Artifact name: ghost-vpn-macos
          - Files:
            - GhostVPN-macOS-arm64.dmg
            - GhostVPN-macOS-x64.dmg
          - Rolling release page: https://github.com/${{ github.repository }}/releases/tag/${{ env.RollingReleaseTag }}
          "@ | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

      - name: Remove legacy macOS zip assets from rolling release
        uses: actions/github-script@v7
        with:
          script: |
            const tag = process.env.RollingReleaseTag;
            const { owner, repo } = context.repo;
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            } catch (e) {
              core.info(`Rolling release '${tag}' is missing, skip cleanup.`);
              return;
            }
            const assets = release.data.assets || [];
            for (const asset of assets) {
              if (/^GhostVPN-macOS-(arm64|x64)\.zip$/i.test(asset.name)) {
                core.info(`Deleting legacy asset: ${asset.name}`);
                await github.rest.repos.deleteReleaseAsset({
                  owner,
                  repo,
                  asset_id: asset.id
                });
              }
            }

      - name: Upload archives to rolling GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RollingReleaseTag }}
          name: Ghost VPN Latest Build
          prerelease: false
          make_latest: true
          overwrite_files: true
          body: |
            Автопубликация последней сборки Ghost VPN для macOS.
            Commit: ${{ github.sha }}
            Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          files: |
            ${{ env.SetupPathArm64 }}
            ${{ env.SetupPathX64 }}

      - name: Upload archives to GitHub Release
        if: ${{ github.event.inputs.release_tag != '' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.release_tag }}
          prerelease: true
          files: |
            ${{ env.SetupPathArm64 }}
            ${{ env.SetupPathX64 }}
